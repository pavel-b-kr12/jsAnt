<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title></title>
<script type="text/javascript" src="lib/d3.v5.min.js"></script>
<script src="lib/webgl-utils.js"></script>

<script src="common.js"></script> 
<script> //settings
/*
stt=
{
 h_incr:0.001, //dt
 h_mul:1800,
 h_k1:2/3, //hue rainbow colors positions
 h_k2:1/3,
 zoom:1,
 bNoAudio:false, //false true //do not init audio at start, but only after click Audio btn
 showArr:'field',
 speed:100,  //TODO slow speed less than fps //TODO move to HTML
 AudioFreqMul:1, 
//TODO Audio volume
 viewCenterX:0,
 viewCenterY:0
}
*/
var h_incr=0.001; //dt
var h_mul=1800;
var h_k1=2/3; //hue rainbow colors positions
var h_k2=1/3;
var zoom=1;
var bNoAudio=false; //false true //do not init audio at start, but only after click Audio btn
var showArr='field';
var speed=100;  //TODO slow speed less than fps //TODO move to HTML
var AudioFreqMul=1.01; 
//TODO Audio volume
var viewCenterX=0;
var viewCenterY=0;
var stt={};
function createTemp_settings()
{
 stt.w=ww;
 stt.h=hh;
 stt.h_incr=h_incr.toFixed(6);
 stt.h_mul=h_mul;
 stt.h_k1=h_k1.toFixed(2);
 stt.h_k2=h_k2.toFixed(2);
 stt.zoom=zoom.toFixed(3);
 stt.bNoAudio=bNoAudio;
 stt.showArr=showArr;
 stt.speed=speed;
 stt.AudioFreqMul=AudioFreqMul.toFixed(3);
 stt.viewCenterX=viewCenterX.toFixed(4);
 stt.viewCenterY=viewCenterY.toFixed(4);
 return stt;
}
function paramsToObject_and_Global(entries) {//https://stackoverflow.com/questions/8648892/how-to-convert-url-parameters-to-a-javascript-object
  let result = {}
  for(let entry of entries) { // each 'entry' is a [key, value] tupple
    const [key, value] = entry;
    result[key] = value;
	
	let num=parseFloat(value);
	window[key] = isNaN(num)?value:num; //and upd global var. TODO test if there is speed difference for access //TODO check incorrect val, and set default
  }
  return result;
}
function settingsFromURL()
{
 stt=paramsToObject_and_Global(new URLSearchParams(window.location.search));
}
function URL_upd() //TODO ant type, antF, colorF, pattern
{
 let url_str=new URLSearchParams(createTemp_settings()).toString();//https://stackoverflow.com/questions/6566456/how-to-serialize-an-object-into-a-list-of-url-query-parameters
 let ar=window.location.pathname.split('/');
 history.replaceState(null, null, ar[ar.length-1]+'?'+url_str); 
 //history.replaceState({}, null, 'webGL.htm?'+url_str);//TODO  move zoom do not upd pushState() immediately but after some timer to prevent flood of history  OR replace history replaceState()
  //w=${ww}&h=${hh}&h_incr=${h_incr.toFixed(6)}&h_mul=${h_mul}&h_k1=${h_k1.toFixed(2)}&h_k2=${h_k2.toFixed(2)}
  //&zoom=${zoom.toFixed(3)}&show=${showArrSortcuts_vk[showArr]}&speed=${speed}&xc=${viewCenterX}&yc=${viewCenterY}&afm=${AudioFreqMul.toFixed(3)}&a=${bNoAudio}

} //https://stackoverflow.com/questions/824349/how-do-i-modify-the-url-without-reloading-the-page

var wh;
function resetwh()
{
	settingsFromURL()
	//
	//if(window.innerHeigh!==undefined)
	//{
	//h=window.innerHeigh>1200 ?1024:512; //console.log(window.innerHeigh, 'set hh:', hh);
	//w=window.innerWidth>1100 ?1024:512; //!TODO. this can be done afterpage load
	//}
	//else //TODO check url first
	{ //url ?w=32&h=512

	let searchParams = new URLSearchParams(window.location.search);
		h=searchParams.get('h')
		if(h!=null){
			h=parseInt(h); if(h<32) h=32; else if(h>2048) h=2048;
		}
		w=searchParams.get('w')
		if(w!=null){
			w=parseInt(w); if(w<32) w=32; else if(w>4096) w=4096;
		}
	}
	hh = h==null?1024:h;
	ww = w==null?1024:w;
	console.log('set w,h, arrays to: ', ww,hh);

 wh=ww*hh;
 xc=ww/2;
 yc=hh/2;
 xM=ww-1;
 yM=hh-1;

chartSize=hh; //! legasy
dataSize=hh//! legasy


 field = new Uint8Array(wh);
 //2D array [x][y] tested as slower https://stackoverflow.com/questions/1242705/performance-of-2-dimensional-array-vs-1-dimensional-array
 field_f= new Float32Array(wh); //for ant_f
// field = d3.range(dataSize).map(function(d, i){return d3.range(dataSize).map(function(d, i){return 0;});});//return ~~(i%2*255); //d3 way became to faster working aray 10-15%. d3.v5>v3 also Opera>>Chromium>>FF
/* //this is slower than D3 in LOOP 8M iterations =140ms vs 122ms @d3
 field = new Array(dataSize);
 for (let i=0; i<dataSize; ++i) {
	field[i] = new Uint8Array(dataSize);
		 for (let j=0; j<dataSize; ++j) {			 field[i][j]=0;		 }
	}
	*/

 arrHist = new Uint32Array(wh);
 arrVisits = new Uint32Array(wh);

 arrHistDir_E = new Uint32Array(wh);
 arrDir_last = new Uint8Array(wh);
 arrHistDirAbs = new Uint8Array(wh);

 arrHist_rotSpeed = new Uint32Array(wh);

//field.fill(4, 1, 3); //val, start, end

// field =Array(ww).fill(Array(hh)); //Rows are copied by reference
//https://stackoverflow.com/questions/1295584/most-efficient-way-to-create-a-zero-filled-javascript-array

//TODO filled area per t, 	end point distance per t
}
resetwh();
</script>
<script src="ant.js"></script>
<style>
.pa {color: red;}
.viewport {position: absolute;}
.abs {position: absolute; }
.shortcut{
	text-decoration: underline; 
	background-color: #ffeecc;
	text-transform: capitalize;/* affect innerText, but not .textContent */
}
.horContainer { display: flex;}
#inf{width: 280px;}
fieldset {
	background-color: #eeeeee;
}

legend {
	background-color: #bdbcbc;

	/*color: white;*/
	/*border: aqua; 7efcff;*/
	/* border-width: 1px;*/
	/* border-style: solid;*/

	padding-inline-start: 0px;
	padding-inline-end: 0px;
}

.label
{
	padding: 6px 14px;
}
.r{float: right;}
.shrtcutBtn_sel
{
	background-color: #bdbcff;
}
</style>
<style>
.w3-black, .w3-hover-black:hover {
	color: #fff!important;
	background-color: #515151/*#7b6d6d!important;*/
}
.w3-bar {
	width: 100%;
	overflow: hidden;
}
.w3-bar .w3-button {
	white-space: normal;
}

.w3-bar .w3-bar-item {
	padding: 3px 14px;
	float: left;
	width: auto;
	border: none;
	display: block;
	outline: 0;
}

.w3-btn {
	border: none;
	display: inline-block;
	padding: 6px 14px;
	vertical-align: middle;
	overflow: hidden;
	text-decoration: none;
	color: inherit;
	background-color: inherit;
	text-align: center;
	cursor: pointer;
	white-space: nowrap;
	box-shadow:0 5px 10px 0 rgba(0,0,0,0.2),0 4px 12px 0 rgba(0,0,0,0.19);
}

.w3-btn:hover {
  background-color: #cccccc!important;
  color: #333!important;
  border: none;
}

.w3-btn:active {
  background-color: #aaaaaa!important;
  color: #050!important;
  box-shadow: none;
  border: none;
}
</style>
	
</head>
<body>

<div class="horContainer">
<div class="hor" id='inf'>
ms walk+draw<br><i id="dtAnt"></i> + <i id="dtDraw"></i> <br>
dirAbs <i id='dirAbs'></i><br>
step <i id='step_i'></i><br>
rot speed <i id='rotSpeed'></i><br>
antrotSpeed <i id='antrotSpeed'></i><br>
frame_i <i id='il'></i><br>
dH/dStep <i id='dHdStep'></i><br>
dH/dFrame_i <i id='dHdFrame_i'></i><br>

AudioFreq of selected <i id='AudioFreq'></i><br>

<button onclick="$('canvas').requestFullscreen();">Fullscreen canvas</button>
<br>
<button onclick="window.location.replace(window.location.pathname)">reload empty</button> 
</div>


<div class="hor">
<button id='stop_sw'  onclick="swStartStop()">start<p class='pa'>To start Click! or press ` 1....9 (speed)</p></button> <!--TODO dont start audio if stopped manually -->
<br>
To view arrays of fieds press keyboard:<br>
<button class='shrtcutBtn' title='f'>field</button> 
<button class='shrtcutBtn' title='h'>arrHist</button> 
<button class='shrtcutBtn' title='v'>arrVisits</button> 
<button class='shrtcutBtn' title='d'>arrDir_last</button> 
<button class='shrtcutBtn' title='e'>arrHistDir_E</button> 
<button class='shrtcutBtn' title='r'>arrHistDirAbs</button> 
<button class='shrtcutBtn' title='s'>arrHist_rotSpeed</button> 
<br>
<input id='slider_speed' type="range" min="0" max="200" value="10" oninput="speed=Math.pow(this.value,3);$tx('slider_speed_txt',speed);URL_upd();"> <i id='slider_speed_txt'>sim </i> speed ops/Frame<br><!-- TODO2 negative speed -->

<input id='slider_h_incr' type="range" min="1" max="200" value="1" oninput="h_incr=Math.pow(value*0.001,2); $tx('slider_h_incr_txt', h_incr.toFixed(6));URL_upd();"> <i id='slider_h_incr_txt'></i> h_incr<br>
<input id='slider_h_mul' type="range" min="1" max="200" value="40" oninput="h_mul=Math.pow(value,2);$tx('slider_h_mul_txt', h_mul*h_mul_mul.toFixed(8)); URL_upd();"> <i id='slider_h_mul_txt'></i> h_mul<br>
<input id='slider_h_k1' type="range" min="1" max="200" value="66" oninput="h_k1=value/100;$tx('slider_h_k1_txt', h_k1);URL_upd()"> <i id='slider_h_k1_txt'></i> h_k1<br>
<input id='slider_h_k2' type="range" min="1" max="200" value="33" oninput="h_k2=value/100;$tx('slider_h_k2_txt', h_k2);URL_upd()"> <i id='slider_h_k2_txt'></i> h_k2<br>
<input id='slider_zoom' type="range" min="1" max="100" value="33" oninput="zoom=value/50; if(zoom>0.7&&zoom<1.3)zoom=1; $tx('slider_zoom_txt', zoom);URL_upd()"> <i id='slider_zoom_txt'></i> zoom (bettter use mouse)<br>
AudioFunc: TODO
 <!-- 216 speed ops/Frame -->
 <!-- 9 rAudioFreq Multiplyer -->
 <!-- 0.000289 h_incr -->
 <!-- 0.000036 h_mul -->

</div>
<div class="hor">
<fieldset>
<legend style="border: 1px solid; width:500px;">
<span class='label'>settings of current ant</span><select id="new_antFuncs" onclick="select_ant(this)" class="abs"></select><span class='r w3-bar-item w3-btn' onclick="new_ant(ant)">new_ant</span><span class='r w3-bar-item w3-btn' onclick="new_ant(ant_f)">new_ant float</span>
</legend>
<input id='sliderdirM_L' type="range" min="2" max="100" value="3" oninput="dirM_L=Math.min(this.value,dirM); $tx('sliderdirM_L_txt', dirM_L)">
<i id='sliderdirM_L_txt'>3</i>dirM_L max dir when turn left, 3 by default, cant be more than dirM<br>

<input id='sliderdirM' type="range" min="2" max="100" value="3" oninput="dirM=Math.max(this.value,dirM_L); $tx('sliderdirM_txt', dirM)">
<i id='sliderdirM_txt'>3</i>dirM max dir when turn right, 3 by default<br>
<legend id='ant_f_settings' style="background-color: #dddddd;border: 1px solid">
<input id='slider_xAdd' type="range" min="-200" max="200" value="22" oninput="xAdd_set(value);"><i id='slide_xAdd_txt'>0.2</i>xAdd<br>
<input id='slider_xSub' type="range" min="-200" max="200" value="22" oninput="xSub_set(value);"><i id='slide_xSub_txt'>0.2</i>xSub<br>
<input id='slider_yAdd' type="range" min="-200" max="200" value="22" oninput="yAdd_set(value);"><i id='slide_yAdd_txt'>0.2</i>yAdd<br>
<input id='slider_ySub' type="range" min="-200" max="200" value="22" oninput="ySub_set(value);"><i id='slide_ySub_txt'>0.2</i>ySub<br>
<input id='add_sub' type="checkbox" > link add_sub
<input id='x_y' type="checkbox" > link x_y
<script>
function xAdd_set(v){
	let val=v/100;
	ant_selected.xAdd=val;		$tx('slide_xAdd_txt', val.toFixed(2));
	
	let add_sub=$('add_sub').checked;
	let x_y=$('x_y').checked;
	
	if(add_sub) xSub_set(v, true);
	if(x_y) yAdd_set(v, true);
	//if(add_sub&&x_y) {ant_selected.ySub=v;	$('slider_ySub').value=$('slider_xAdd').value}
}
function xSub_set(v, bSetRangeValue){
	if( bSetRangeValue)$('slider_xSub').value=v;
	let val=v/100;
	ant_selected.xSub=val;		$tx('slide_xSub_txt', val.toFixed(2));
	
	
	//let add_sub=$('add_sub').checked;
	let x_y=$('x_y').checked;
	
	if(x_y) ySub_set(v, true);
}
function yAdd_set(v, bSetRangeValue){
	if( bSetRangeValue)$('slider_yAdd').value=v;
	let val=v/100;
	ant_selected.yAdd=val;		$tx('slide_yAdd_txt', val.toFixed(2));
	
	let add_sub=$('add_sub').checked;
	//let x_y=$('x_y').checked;
	
	if(add_sub) ySub_set(v, true);
}
function ySub_set(v, bSetRangeValue){
	if( bSetRangeValue)$('slider_ySub').value=v;
	let val=v/100;
	ant_selected.ySub=val;		$tx('slide_ySub_txt', val.toFixed(2));
}
</script>
</legend>
<br style="display: block; margin: 4px 0; content:'';">antFunc <select id="antFuncs" onclick="setantFunc(this.value)" class="abs"></select><br>
</fieldset>
</div>

<div class="hor">
<fieldset style="background-color: #acacac;">
<legend>
<div class="w3-bar w3-black">
<button class="w3-bar-item w3-btn" onclick="fill_field_clear_all()">Fill field with pattern</button>
<button class="w3-bar-item w3-btn" onclick="clear_AllArr()">clear all</button>
</div>
</legend>
pattern:
<br>
<input id='canvasFill_wE' type="range" min="1" max="8" value="2" oninput="canvasFill_wE=this.value;drawBox(); $tx('canvasFill_wE_txt', canvasFill_wE)"><i id='canvasFill_wE_txt'></i> w  
<input id='canvasFill_hE' type="range" min="1" max="8" value="2" oninput="canvasFill_hE=this.value;drawBox(); $tx('canvasFill_hE_txt', canvasFill_hE)"><i id='canvasFill_hE_txt'></i> h<br>
TODO color to be same as in shader, same as in ant function<br>

<canvas id="canvasFill" width="140px" height="140px"></canvas>

<input id='slider_fieldAdd' type="range" min="2" max="64" value="8" oninput="fieldAdd=value; $tx('slider_fieldAdd_txt', zoom);URL_upd()"> add to field each <i id='slider_fieldAdd_txt'></i> turn<br>
</fieldset>

</div>


<div class="hor">
<fieldset style="background-color: #acacac;">
<legend>

<div class="w3-bar w3-black">
<span>**</span>
<button onclick="bNoAudio=!bNoAudio; sw_AllowAudio(); URL_upd();" title='or click canvas'>𝄞 ♫ <b class=shortcut>A</b>udio  is OFF</button> 
<button class="w3-bar-item w3-btn" onclick="fill_field_clear_all()">Fill field with pattern</button>
<button class="w3-bar-item w3-btn" onclick="clear_AllArr()">clear all</button>


</div>
</legend>
pattern:
<br>
<input id='slider_AudioFreqMul' type="range" min="1" max="100" value="1" oninput="AudioFreqMul=this.value*1;$tx('slider_AudioFreqMul_txt',AudioFreqMul);URL_upd();"> <i id='slider_AudioFreqMul_txt'></i> rAudioFreq Multiplyer<br>

</fieldset>

</div>


</div>

<canvas id='canvas' class='viewport'></canvas>

<script> //key
var bWaitKeyUp=false;
function setSpeed(v){
	if(v==0){swStartStop(false);}
	else
	{
		v=Math.pow(10,v-1);
		if(speed==v) {swStartStop();}
		else {speed=v;  if(bStop) swStartStop(true); }
	}
	if(Math.abs(speed)>10000000) speed=10000000;
	$('slider_speed').value=Math.pow( speed, 0.333333);
	$tx("slider_speed_txt",speed);	//console.log(speed);
}

//var bMobile = navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(android)|(webOS)/i)
document.body.onkeyup = function(e){
	bWaitKeyUp=false;
	if(e.keyCode == 32){$('stop_sw').click()}
	else{
	 //if(!bMobile)	$('btn_show_field').click() //show different maps only while pressing key
	}
}

document.body.onkeydown = function(e){
	if(bWaitKeyUp) return; //to make keys responce faster - function handle press but not up
	bWaitKeyUp=true;
	//console.log(e.key, e.keyCode, String.fromCharCode(e.keyCode)) //codes https://stackoverflow.com/questions/3781142/jquery-or-javascript-how-determine-if-shift-key-being-pressed-while-clicking-an
	if( e.keyCode==46){fill_field_clear_all(); return; } //del
	if( 
	e.key==1 ||
	e.key==2 ||
	e.key==3 ||
	e.key==4 ||
	e.key==5 ||
	e.key==6 ||
	e.key==7 ||
	e.key==8 ||
	e.key==9
	) setSpeed(e.key);
	else
	if( e.keyCode==192) setSpeed(0);//`
	else
	{
		if(e.keyCode >= 65 && e.keyCode <= 90) 
		{
			sortcutPress(String.fromCharCode(e.keyCode).toLowerCase());
		}
	}
}

function sortcutPress(k){
	//showArr=(showArrSortcuts[k]!==undefined)?showArrSortcuts[k]:'field'; //without btns
	$('shrtcutBtn'+k).click();
}
var shrtcutBtn_last=null;
function shrtcutBtn_click(e){
	el=e.target;
	if(el.tagName=='B')el=el.parentElement;
	
	if(el==shrtcutBtn_last) return;
	
	el.classList.toggle('shrtcutBtn_sel');
	if(shrtcutBtn_last!=null) shrtcutBtn_last.classList.remove('shrtcutBtn_sel');
	shrtcutBtn_last=el;
	
	showArr=el.textContent;	//console.log(e.target.innerText, e.target.textContent);
}
showArrSortcuts=[];//filled with tag titles 'f', 'h' ...
showArrSortcuts_vk=[];//value:key to search keys
</script>
<script> //init

window.onload=setup;
function setup(){
//-------- shrtcutBtn events
	let ar=document.getElementsByClassName('shrtcutBtn');
	for(let i=0;i<ar.length;i++)
	{
		let k=ar[i].title;
		
		ar[i].id='shrtcutBtn'+k;
		ar[i].addEventListener('click', shrtcutBtn_click);
		
		let K=k.toUpperCase(); //k is lower case
		let str=ar[i].innerText;
		showArrSortcuts[k]=str;		showArrSortcuts_vk[str]=k;
		ksearch=(str.indexOf(K)==-1)?k:K; //if no UpperCase - search lower 		//TODO if no any - add k to element
		str=str.replace(ksearch, '<b class=shortcut>'+ksearch+'</b>'); //remain case. Show UpperCase via css if no UpperCase in string
		ar[i].innerHTML=str;
	}
}

</script>
<script>  //select function list
new_sel=$('new_antFuncs');
new_sel.addEventListener('mouseenter', select_ant_sel_dropdown);
new_sel.addEventListener('mouseleave', antFuncs_sel_off);

function new_ant(o)
{
 let a=Object.create(o);
 ants.push(a);
 ant_selected_set(a)
 if(ant_selected.bFloatDir) dirM=4;
 recreate_ants_sel_list();
 new_sel.selectedIndex=ants.length-1;
}

var ants=[];
ant.antFunc=antFF.RL;
ant_f.antFunc=antFF_f.RL;
new_ant(ant) //start with integer ant as it simpler and easy to make good audio
//new_ant(ant_f)

antFF_nm_list=  Object.getOwnPropertyNames(antFF).filter(function (p) {
	return typeof antFF[p] === 'function';
})


//@2 https://www.w3.org/TR/wai-aria-practices-1.1/examples/listbox/listbox-rearrangeable.html
var sel = $('antFuncs');
var fragment = document.createDocumentFragment();
antFF_nm_list.forEach(function(nm, index) {
	var opt = document.createElement('option');
	opt.innerHTML = nm;
	opt.value = nm;
	opt.id=nm
	fragment.appendChild(opt);
});
sel.appendChild(fragment);
sel.addEventListener('mouseenter', antFuncs_sel_dropdown);
sel.addEventListener('mouseleave', antFuncs_sel_off);



function antFuncs_sel_dropdown(e){
	e.target.setAttribute('size',e.target.length)
	e.target.style.zIndex=9;
}
function antFuncs_sel_off(e){
	e.target.removeAttribute('size')
	e.target.style.zIndex=0;
}

function select_ant_sel_dropdown(e){
	e.target.setAttribute('size',e.target.length)
	e.target.style.zIndex=9;
}
function recreate_ants_sel_list()
{
	N=new_sel.selectedIndex;
	new_sel.innerHTML="";
	fragment = document.createDocumentFragment();
	for(let i=0;i<ants.length;i++)
	{
		var opt = document.createElement('option');
		let str_f=ants[i].bFloatDir?"f":"";
		let str=i+str_f+" "+ ants[i].antFunc.name; 		//console.log(str);
		opt.innerHTML = str;
		opt.value = i;
		opt.id=str
		fragment.appendChild(opt);
	}
	new_sel.appendChild(fragment);
	new_sel.selectedIndex=N;
}


function setantFunc(nm){
	ant_selected.antFunc=antFF[nm]; //console.log(nm,antFF[nm]);
	recreate_ants_sel_list();
	//!upd ants list
}

function ant_selected_set(a){
	ant_selected=a; 
	$('ant_f_settings').style.display=ant_selected.bFloatPos?'block':'none';
}
function select_ant(e){
 ant_selected_set(ants[e.value])	//antFunc=antFF[nm]; 	//console.log(nm,antFF[e.id]);
}

function del_selected_ant(){
 ants.splice(ants.indexOf(a.antFunc.name), 1);
}


//$(antFF_nm_list[0])
</script>
<script>//fill
var canvasFill_wE=2,canvasFill_hE=2;
canvasFil_patternlArrSizeM=8
var canvasFil_patternlArr = d3.range(canvasFil_patternlArrSizeM).map(function(d, i){return d3.range(canvasFil_patternlArrSizeM).map(function(d, i){return 0;});});

var canvasFill = document.getElementById("canvasFill"),
	canvasFill_ctx = canvasFill.getContext("2d"),
	boxSize = 20,
	boxes = Math.floor(canvasFill.width / boxSize);
canvasFill.addEventListener('click', canvasFill_Click);
//canvasFill.addEventListener('mousemove', canvasFill_Click);

function drawBox() { //initial draw of empty grid
	canvasClear(canvasFill);
	canvasFill_ctx.beginPath();
	canvasFill_ctx.fillStyle = "white";
	canvasFill_ctx.lineWidth = 2;
	canvasFill_ctx.strokeStyle = 'black';
	for (var row = 0; row < canvasFill_hE; row++) {
		for (var column = 0; column < canvasFill_wE; column++) {
		  var x = column * boxSize;
		  var y = row * boxSize;
		  canvasFill_ctx.rect(x, y, boxSize, boxSize);
		  canvasFill_ctx.fill();
		  canvasFill_ctx.stroke();
		}
	}
	canvasFill_ctx.closePath();
}
var colorFill_i=0;
var colorFill_iE=6;
var colors= [ 'black', 'white', 'blue', 'red', 'green', 'yellow', 'purple', 'aqua', 'fuchsia', 'gray', 
'lime', 'maroon', 'navy', 'olive', 'orange', 
'silver', 'teal'];
/*var colorsABC= ['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 
'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 
'silver', 'teal', 'white', 'yellow'];*/
var canvasFill_Click_pos_old=-1;
function canvasFill_Click(e) {
	let row=Math.floor(e.offsetX / boxSize)
	let column=Math.floor(e.offsetY / boxSize)
	
	
	let pos=row*canvasFill_hE+column;
	if(canvasFill_Click_pos_old==pos) //change color only if clicking again
	{
		colorFill_i++; colorFill_i%=colorFill_iE;
	}
	canvasFill_Click_pos_old=pos;
	
	canvasFill_ctx.fillStyle=colors[colorFill_i] //RGBArr2HTML(hsvToRgb(colorFill_i/colorFill_iE,1,1))
	canvasFill_ctx.fillRect(row * boxSize,	column * boxSize,	boxSize, boxSize);

	canvasFil_patternlArr[column][row]=colorFill_i;
	
	fill_field(1);
}

drawBox();


function fill_field(b_fill_w_pattern)
{
	for(let y=0, n=0;y<hh;y++){
		for(let x=0;x<ww;x++,n++) {
			let pos=x*hh+y;
			 field[pos]= b_fill_w_pattern ?
				canvasFil_patternlArr[y%canvasFill_hE][x%canvasFill_wE]*222/colorFill_iE //fill field with pattern from canvasFil_patternlArr
				: 0; 
			}
	}
}

function fill_field_clear_all()
{
	fill_field(1); clearAll();
}
function clear_AllArr()
{
	fill_field(0); clearAll();
}
function clearAll() //except field
{
	for(let i=0;i<wh;i++){
			 arrHist[i] =0;
			 arrVisits[i] =0;
			 arrHistDir_E[i] =0;
			 arrDir_last[i] =0;
			 arrHistDirAbs[i] =0;
			 arrHist_rotSpeed[i] =0;
	}
}
</script>

<script> //loop
var canvas = $('canvas');
canvas.width=ww;
canvas.height=hh;

var lastX,lastY;
var dragEnd_dX=0;
var dragEnd_dY=0;
var lastX=1/2,lastY=1/2;


var dragStart,dragged;
addEvents_panZoom_ToCanvasView(canvas);
function addEvents_panZoom_ToCanvasView(canvasView)
{	console.log(ww,hh,lastX,lastY)
	lastX=canvasView.width/2;
	lastY=canvasView.height/2;

	canvasView.addEventListener('mousedown',function(evt){
		document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = 'none';
		lastX = evt.offsetX || (evt.pageX - canvasView.offsetLeft);
		lastY = evt.offsetY || (evt.pageY - canvasView.offsetTop);
		dragStart =[lastX,lastY];// ctxView.transformedPoint(lastX,lastY);
		dragged = false;
				//console.log(lastX,lastY)
	},false);
	canvasView.addEventListener('mousemove',function(evt){
		lastX = evt.offsetX || (evt.pageX - canvasView.offsetLeft);
		lastY = evt.offsetY || (evt.pageY - canvasView.offsetTop);
		dragged = true;
		if (dragStart){
			//pt = ctxView.transformedPoint(lastX,lastY);
			//ctxView.translate(pt.x-dragStart.x,pt.y-dragStart.y);
			//redraw();
			viewCenterX=(lastX-dragStart[0])/canvasView.width*zoom+dragEnd_dX;
			viewCenterY=(lastY-dragStart[1])/canvasView.height*zoom+dragEnd_dY;	//console.log(viewCenterX,viewCenterY)
		}
				//console.log(lastX,lastY)
				if(il%16==0)	URL_upd();
				//#fix position glitch on first down 
	},false);
	canvasView.addEventListener('mouseup',function(evt){
		dragStart = null;
		if (!dragged) Zoom(evt.shiftKey ? -1 : 1 );
		else
		{
			dragEnd_dX=viewCenterX;
			dragEnd_dY=viewCenterY;
			//console.log(dragEnd_dX,dragEnd_dY)
			URL_upd();
		}
	},false);

	scaleFactor = 1.1;
	var Zoom = function(clicks){ //console.log(clicks)
		//pt = ctxView.transformedPoint(lastX,lastY);
		//ctxView.translate(pt.x,pt.y);
		var factor = Math.pow(scaleFactor,clicks);
		//ctxView.scale(factor,factor);
		//ctxView.translate(-pt.x,-pt.y);
		//redraw();
	}

	var handleScroll = function(evt){ //console.log(evt.wheelDelta, zoom)
		zoomOld=zoom;
		zoom_t*=evt.wheelDelta>0?0.9:1.1;		if(zoom_t>0.8&&zoom_t<1.2) zoom=1; else zoom=zoom_t;
		$('slider_zoom').value=zoom*50;
		URL_upd();
		
		viewCenterX+=lastX/canvasView.width*(zoom-zoomOld);
		viewCenterY+=lastY/canvasView.height*(zoom-zoomOld);
		dragEnd_dX=viewCenterX;
		dragEnd_dY=viewCenterY;
		
		//var delta = evt.wheelDelta ? evt.wheelDelta/40 : evt.detail ? -evt.detail : 0;
		//if (delta) Zoom(delta);
		return evt.preventDefault() && false;
	};
	canvasView.addEventListener('DOMMouseScroll',handleScroll,false);
	canvasView.addEventListener('mousewheel',handleScroll,false);
}
var zoom_t=1;

const gl = canvas.getContext("webgl", { alpha: false }); //if (!gl) {alert('no webgl')}

let programInfo = webglUtils.createProgramInfo(
   gl, [
`
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;

varying vec2 v_texCoord;

void main() {
   //gl_PointSize = 12.0;
  
   vec2 zeroToOne = a_position / u_resolution; // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToTwo = zeroToOne * 2.0; // convert from 0->1 to 0->2
   vec2 clipSpace = zeroToTwo - 1.0; // convert from 0->2 to -1->+1 (clipspace)

   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); //@@@a_position //TODO pan, zoom here

   // pass the texCoord to the fragment shader. The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
`
, //==================================
`
precision highp float;

uniform sampler2D u_image;
uniform vec2 u_textureSize;

varying vec2 v_texCoord; //from the vertex shader

uniform float timestamp;
uniform float h_mul;
uniform float h_k1;
uniform float h_k2;
uniform float zoom;
uniform vec2 view_center;

/*
// All components are in the range [0…1], including hue.
vec3 rgb2hsv(vec3 c)
{
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
	vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
*/
 
// All components are in the range [0…1], including hue.
vec3 hsv2rgb(vec3 c)
{
	//vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec4 K = vec4(1.0, h_k1, h_k2, 3.0); //! TODO i want more palette control control, some gradients with 'stops'
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
/*
// Official HSV to RGB conversion 
vec3 hsv2rgb( in vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );

	return c.z * mix( vec3(1.0), rgb, c.y);
}
//TODO use (seems diff is small here), but it has to be better sometimes https://www.shadertoy.com/view/MsS3Wc
// Smooth HSV to RGB conversion 
vec3 hsv2rgb_smooth( in vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );

	rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing	

	return c.z * mix( vec3(1.0), rgb, c.y);
}
*/
void main() {
	//vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
	//gl_FragColor = (
	//	 texture2D(u_image, v_texCoord) +
	//	texture2D(u_image, v_texCoord + vec2(onePixel.x, 0.0)) +
	//	texture2D(u_image, v_texCoord + vec2(-onePixel.x, 0.0))) / 3.0;
	   
	//gl_FragColor = vec4(v_texCoord.x, v_texCoord.y, 0, 1); 
	
	float c0=texture2D(u_image, v_texCoord*zoom-view_center).x;
	if(c0==0.)
	{
		gl_FragColor = vec4(0.,0.,0.,1.);
		return;
	}
	
	vec3 c=vec3(sin(c0*h_mul+timestamp),1.,1.);
	
	c=hsv2rgb(c);

	gl_FragColor = vec4(c,1.);
	
	
	/*
	if(texture2D(u_image, v_texCoord).x>0.1)
		gl_FragColor = vec4(1.,0.,0.,1.);
	else
	if(texture2D(u_image, v_texCoord).x>0.5)
		gl_FragColor = vec4(0.,1.,0.,1.);
	else
		gl_FragColor = vec4(0.,0.,1.,1.);
	*/

	
	//gl_FragColor = vec4( hsv2rgb(c), 1.);
	//gl_FragColor = texture2D(u_image, v_texCoord)+vec4(v_texCoord.x, v_texCoord.y, 0, 1); //vec4(1, 0.5, 0, 1);
}



`
]);


//=============================================

/*
let tex_size = 256;


texAr=new Uint8Array(tex_size*tex_size);
fillArray(texAr, 1)
texAr=new Float32Array(tex_size*tex_size);
fillArray(texAr, 1)
function fillArray(arr, valPerPixel)
{
	for(let y=0, n=0;y<tex_size;y++){
		for(let x=0;x<tex_size;x++,n++) {
			arr[n*valPerPixel]=n;
			//arr[n*valPerPixel]=x+y;
		}
	}
}
*/
/*
let tex_size = 256;


texArr_8=new Uint8Array(tex_size*tex_size);
for(let y=0, n=0;y<tex_size;y++){
	for(let x=0;x<tex_size;x++,n++) {
		texArr_8[n]=x+y;
	}
}
		
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ww, hh, 0, gl.RGBA, gl.UNSIGNED_BYTE, texArr); //working

texArr_RGBA8=new Uint8Array(tex_size*tex_size*4);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, ww, hh, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, texArr); //working


texArr_32F=new Float32Array(tex_size*tex_size);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, ww, hh, 0, gl.R32F, gl.FLOAT, texArr); //Error  gl.FLOAT invalid type

texArr_RGBA32F=new Float32Array(tex_size*tex_size*4);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ww, hh, 0, gl.RGBA, gl.FLOAT, texArr); //Error  gl.FLOAT invalid type
*/

let floatTextures = gl.getExtension('OES_texture_float'); if (!floatTextures) { alert('no floating point tex support');/*use color.r + color.g * 256.0f*/}
//,OES_texture_half_float //16b  

//=============================================
//texArr=new Uint8Array(wh)
texArr=new Float32Array(wh)

var dt_avg=10, dtAnt=20, dtDraw=20;
var bStop=true; //initial is stopped, because of need click to init audio
var il=0;
var upd_gui_i=0;
var timestamp=0;
var timestamp_t=0;
//changing by colorize modes:
var h_mul_mul=0.001;
var h_incr_mul=1;

function loop(timestamp) {
timestamp=timestamp_t //!fix something increment this if delete this it will still increasing %\
timestamp_t+=h_incr*h_incr_mul;
	var t0=window.performance.now();
	
	for (let i = 0; i < speed; i++) { //100000000 =10M=1s on opera2020  //310+35ms separate field arr
	for(let i=0;i<ants.length;i++)
	{
		 ants[i].run();
		 //bStop=true; //single step mode press btn //sleep(500)
		}
	}

	var tA=window.performance.now();

/*
			c = ((i & 8) ^ (j & 8))*255;
texArr[(y*ww+x)*4] = 222; // Red component
texArr[(y*ww+x)*4+1] = 111; // Green component
texArr[(y*ww+x)*4+2] = c; // Blue component
texArr[(y*ww+x)*4+3] = 0xff; // Alpha component
*/


	switch(showArr)
	{
		default:
		case 'field':
		h_mul_mul=0.0000005;
		h_incr_mul=0;
		//for(let y=0, n=0;y<hh;y++){
		//for(let x=0;x<ww;x++,n++) {
			//let pos=x*hh+y;
		//	let value = field[n];
			//if(value==0&&buffer32[n]==0) continue; //skip unused
			//if(value!=0&& buffer32[n]!=0) continue;
			
		//	texArr[n] = value;
		//}
		//}
		for(let i=0;i<wh;i++){
			texArr[i] = field[i];
			//if(arrVisits[i]==0){texArr[i] = field[i];} //only first
		}
		break;
		
		case 'arrHist':
		h_mul_mul=0.0000001;
		h_incr_mul=10;
		for(let i=0;i<wh;i++)
			texArr[i] = arrHist[i];
		break;
		case 'arrVisits':
		h_mul_mul=0.000003;
		h_incr_mul=1;
		for(let i=0;i<wh;i++)
			texArr[i] = arrVisits[i];
		break;

		case 'arrDir_last':
		h_mul_mul=0.01; //!!
		h_incr_mul=1;
		for(let i=0;i<wh;i++)
			texArr[i] = arrDir_last[i];
		break;
		
		case 'arrHistDir_E':
		h_mul_mul=0.00005;
		h_incr_mul=1;
		for(let i=0;i<wh;i++)
			texArr[i] = arrHistDir_E[i];
		break;
		
		case 'arrHistDirAbs':
		h_mul_mul=0.00001;
		h_incr_mul=1;	
		for(let i=0;i<wh;i++)
			texArr[i] = arrHistDirAbs[i];		
		break;
		
		case 'arrHist_rotSpeed':
		h_mul_mul=0.00001;
		h_incr_mul=0; //TODO but change with slider
		for(let i=0;i<wh;i++)
			texArr[i] = arrHist_rotSpeed[i];
		break;
	}



 //var rgbaTex = textureFromPixelArray(gl, texArr, gl.RGBA, ww, hh); //convert texArr to Uint8Array


if(il==0){
  let textureField = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, textureField);

  let texWrap=gl.CLAMP_TO_EDGE;
  if(powerOf2(ww) && powerOf2(hh)) // can't have repeating non power of 2 textures, but CLAMP_TO_EDGE is allowed
  {
	texWrap=gl.REPEAT;
  }  else {   console.log('wrap disabled: NPOT texure size')  }
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texWrap); //REPEAT CLAMP_TO_EDGE MIRRORED_REPEAT
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texWrap); 
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}
  // Upload the image into the texture.
  //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ww, hh, 0, gl.RGBA, gl.UNSIGNED_BYTE, texArr); // new Uint8Array(texArr)
  //gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, ww, hh, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, new Uint8Array(texArr));
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, ww, hh, 0, gl.LUMINANCE, gl.FLOAT, texArr);

  gl.uniform1f(timestampId, timestamp); 
  gl.uniform1f(h_mulId, h_mul*h_mul_mul); 
  gl.uniform1f(h_k1Id, h_k1); 
  gl.uniform1f(h_k2Id, h_k2); 
  gl.uniform1f(zoomId, zoom); 
  gl.uniform2f(view_centerId, viewCenterX,viewCenterY);  //console.log(viewCenterX,viewCenterY)
  //gl.uniform1i(texId, tar); //unnecessary

  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);  // set the resolution
  gl.uniform2f(textureSizeLocation, ww, hh); // set the size of the image
  
  // Draw the rectangle.
  gl.drawArrays(gl.TRIANGLES, 0, 6); //primitiveType offset count
  
	
	dtAnt=dtAnt*0.9+(tA-t0)*0.1;
	dtDraw=dtDraw*0.9+(window.performance.now()-tA)*0.1;
	if(upd_gui_i==0)
	{
	upd_gui_i=8; //upd freq
	let dt0=window.performance.now()-t0; dt_avg=Math.abs((dt0-dt_avg)/dt_avg)>0.2?dt0: dt_avg*0.95+(window.performance.now()-t0)*0.05;
	
	$('dtAnt').innerText=dtAnt.toFixed(1);
	$('dtDraw').innerText=dtDraw.toFixed(1);
	$('dirAbs').innerText=ant_selected.dirAbs.toFixed(4)
	$('step_i').innerText=ant_selected.step_i
	
	let crotSpeed=((ant_selected.dirAbs-ant_dirAbs_last)/(ant_selected.step_i-ant_step_i_last))
	$('rotSpeed').innerText=crotSpeed.toFixed(2)
	$('antrotSpeed').innerText=ant_selected.rotSpeed.toFixed(2)
	$('il').innerText=il
	
	ant_dirAbs_last=ant_selected.dirAbs;
	ant_step_i_last=ant_selected.step_i;
	

	if(binit_Audio && osc.bOn)
	{
		let Timeout=dt0
		//let freq_new=30+Math.abs(ant_selected.rotSpeed)*AudioFreqMul; //
		let freq_new=500+ant_selected.rotSpeed*AudioFreqMul;	if(freq_new<30) freq_new=30+Math.abs(freq_new-30)
		if(freq_avg==0) freq_avg=freq_new;
		else 
		{
			freq_avg=freq_new;
			//if(freq_mode=='strict_dt'){
			//
			//	if(Math.abs(freq_avg-freq_new)<Timeout/8) //8hz/ms
			//			freq_avg=freq_avg;
			//	else 
			//	{
			//		if(Timeout>50)
			//			freq_avg=freq_avg*0.5+freq_new*0.5;
			//		else
			//			freq_avg=freq_avg*0.6+freq_new*0.4;
			//	}
			//}
		}
		osc.frequency.linearRampToValueAtTime(freq_avg,context.currentTime+Timeout/1000); $('AudioFreq').innerText=Math.floor(freq_avg);
	}
	}
	else upd_gui_i--;
	il++;
	
	if(!bStop)	frameNID=requestAnimationFrame(loop)
}
var frameNID=-1;// №
	let ant_dirAbs_last=0;
	let ant_step_i_last=0;

var bBeforeStart=true;
function swStartStop(b) //true to start.	undefined to toggle
{
	bBeforeStart=false;
	if(b===undefined)	bStop=!bStop;
	else bStop=!b;
	
	$tx('stop_sw',bStop?'start':'stop');
	
	if(!binit_Audio) init_Audio();
	else sw_Audio();
	
	if(bStop)
	{
		if(frameNID>=0) cancelAnimationFrame(frameNID);
	}
	else
	{
		frameNID=requestAnimationFrame(loop);
	}
}
	var osc;
	var context;
	var freq_avg=0;

	//canvas.onclick=sw_AllowAudio	//document.onclick=sw_Audio
var binit_Audio=false;
function init_Audio(){
	if(bNoAudio==true) return;
	context = new(window.AudioContext || window.webkitAudioContext)();
	osc = context.createOscillator(); 
	// Sine is the default type. Also available: square, sawtooth and triangle waveforms.
	osc.type = 'sine'; 
	var now = context.currentTime;
	osc.frequency.setValueAtTime(440, now);
	osc.connect(context.destination); //== const osc = new Tone.Oscillator(440, "sine").toDestination().start();
	osc.frequency.setValueAtTime(440, now+1);
	osc.start(now);  
	
	binit_Audio=true;
	osc.bOn=true;
}
var bAllowAudio=true; // not Mute //! TODO re to bMute
function sw_AllowAudio(){ //console.log(bAllowAudio)
	if(!binit_Audio) init_Audio()
	else
	bAllowAudio=!osc.bOn;
	sw_Audio(bAllowAudio);	//console.log(bAllowAudio)
}
function sw_Audio(bOn) //this is not solving alert "The AudioContext was not allowed to start"
{
	if(!binit_Audio)
	{
		init_Audio(); 
		if(bBeforeStart)	swStartStop();
		return;
	}
	
	if(binit_Audio)
	{
		if(bOn===undefined || typeof bOn!="boolean")  bOn=!osc.bOn;
		osc.bOn=bOn
		//console.log('bOn, bAllowAudio',bOn, bAllowAudio)
		if(bOn)
		{
			if(bAllowAudio)
			{
				//osc.start(now);
				osc.connect(context.destination); 
			}
		}
		else
		{
			osc.disconnect();
			//osc.stop(now);
		}
		return;
	}
}


//##const osc = new Tone.Oscillator(440, "sine").toDestination()
//===========================================

 // look up where the vertex data needs to go.
  const positionLocation = gl.getAttribLocation(programInfo.program, "a_position");
  const texcoordLocation = gl.getAttribLocation(programInfo.program, "a_texCoord");

  // Create a buffer to put three 2d clip space points in
  var positionBuffer = gl.createBuffer();

  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  // Set a rectangle the same size as the image.
  setRectangle(gl, 0, 0, ww, hh);

  // provide texture coordinates for the rectangle.
  var texcoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
	  0.0,  0.0,
	  1.0,  0.0,
	  0.0,  1.0,
	  0.0,  1.0,
	  1.0,  0.0,
	  1.0,  1.0,
  ]), gl.STATIC_DRAW);

  // Upload the image into the texture.
  //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

  // lookup uniforms
  const resolutionLocation = gl.getUniformLocation(programInfo.program, "u_resolution");
  const textureSizeLocation = gl.getUniformLocation(programInfo.program, "u_textureSize");

  //webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // Tell WebGL how to convert from clip space to pixels
  //gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // Clear the canvas
  //gl.clearColor(0, 0, 0, 0);
  //gl.clear(gl.COLOR_BUFFER_BIT);

  // Tell it to use our programInfo.program (pair of shaders)
  gl.useProgram(programInfo.program);

  // Turn on the position attribute
  gl.enableVertexAttribArray(positionLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
  var size = 2;		  // 2 components per iteration
  var type = gl.FLOAT;   // the data is 32bit floats
  var normalize = false; // don't normalize the data
  var stride = 0;		// 0 = move forward size * sizeof(type) each iteration to get the next position
  var offset = 0;		// start at the beginning of the buffer
  gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);

  // Turn on the texcoord attribute
  gl.enableVertexAttribArray(texcoordLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

  // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)
  var size = 2;		  // 2 components per iteration
  var type = gl.FLOAT;   // the data is 32bit floats
  var normalize = false; // don't normalize the data
  var stride = 0;		// 0 = move forward size * sizeof(type) each iteration to get the next position
  var offset = 0;		// start at the beginning of the buffer
  gl.vertexAttribPointer( texcoordLocation, size, type, normalize, stride, offset);

  const texId = gl.getUniformLocation(programInfo.program, 'u_image');
  const timestampId = gl.getUniformLocation(programInfo.program, 'timestamp');
  const h_mulId = gl.getUniformLocation(programInfo.program, 'h_mul');
  const h_k1Id = gl.getUniformLocation(programInfo.program, 'h_k1');
  const h_k2Id = gl.getUniformLocation(programInfo.program, 'h_k2');
  const zoomId = gl.getUniformLocation(programInfo.program, 'zoom');
  const view_centerId = gl.getUniformLocation(programInfo.program, 'view_center');


function textureFromPixelArray(gl, dataArray, type, width, height) { //from arr, from  image https://stackoverflow.com/questions/9046643/webgl-create-texture
	var dataTypedArray = new Uint8Array(dataArray); // Don't need to do this if the data is already in a typed array
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texImage2D(gl.TEXTURE_2D, 0, type, width, height, 0, type, gl.UNSIGNED_BYTE, dataTypedArray);
	// Turn off mips and set  wrapping to clamp to edge so it  will work regardless of the dimensions of the video.
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); //gl.NEAREST
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	// Other texture setup here, like filter modes and mipmap generation
	return texture;
}


//----------
function hide_sw(id){
  x=$('id')
  if (x.style.display === "none") {
	x.style.display = "block";
  } else {
	x.style.display = "none";
  }
// $('canvas').classList.toggle('hidden')
}

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
	 x1, y1,
	 x2, y1,
	 x1, y2,
	 x1, y2,
	 x2, y1,
	 x2, y2,
  ]), gl.STATIC_DRAW);
}
</script>

</body>
</html>